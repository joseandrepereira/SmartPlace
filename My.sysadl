Model SysADLModel ; package SmartPlaceDUD { dimension Temperatura unit Celsius { dimension = Temperatura } dimension Presenca unit TemPresenca { dimension = Presenca } } Requirement AutomatizarAmbienteFR ( 1 ) { text = "O sistema deve ser capaz de gerenciar o ambiente de forma automatizada por meio de sensores, aplicativos e painéis." } Requirement GerenciarLigarLuzFR ( 1.2.1 ) { text = "O sistema deve ligar as luzes do ambiente caso ele esteja vazio e chegue uma ou mais pessoas." derive MostrarStatusAmbienteFR.GerenciarLuzesFR ; } Requirement GerenciarDesligarLuzFR ( 1.2.2 ) { text = "O sistema deve desligar as luzes do ambiente caso não tenha pessoas dentro dele." derive MostrarStatusAmbienteFR.GerenciarLuzesFR ; } Requirement GerenciarLigarArCondicionadoFR ( 1.1.1 ) { text = "O sistema deve ligar o ar condicionado do ambiente caso ele esteja vazio e chegue alguém" derive MostrarStatusAmbienteFR.GerenciarTemperaturaFR ; } Requirement GerenciarDesligarArCondicionadoFR ( 1.1.2 ) { text = "O sistema deve desligar o ar condicionado caso não tenha pessoas no ambiente" derive MostrarStatusAmbienteFR.GerenciarTemperaturaFR ; } Requirement GerenciarNivelTemperaturaFR ( 1.1.3 ) { text = "O sistema deve ajustar a temperatura do ambiente para que ela fique de acordo com o dado coletado da temperatura desejada." derive MostrarStatusAmbienteFR.GerenciarTemperaturaFR ; } Requirement MostrarStatusAmbienteFR ( 1.4 ) { text = "O sistema deve mostrar o status do ambiente: mostrar estado das luzes, ar condicionados e quantidade de pessoas" Requirement ColetarTemperaturaDesejadaFR ( 1.1.3.2 ) { text = "O sistema deve coletar a temperatura desejada pelas pessoas do ambiente." derive GerenciarNivelTemperaturaFR ; } Requirement ColetarTemperaturaAmbienteFR ( 1.1.3.1 ) { text = "O sistema deve coletar a temperatura atual do ambiente." derive GerenciarNivelTemperaturaFR ; } Requirement ColetorNumPessoaFR ( 1.3 ) { text = "O sistema deve coletar o número de pessoas que estão no ambiente." derive GerenciarTemperaturaFR , GerenciarLuzesFR ; } Requirement GerenciarTemperaturaFR ( 1.1 ) { text = "O sistema deve ser capaz de gerenciar automaticamente a temperatura do ambiente." derive AutomatizarAmbienteFR ; } Requirement GerenciarLuzesFR ( 1.2 ) { text = "O sistema deve ser capaz de gerenciar as luzes automaticamente." derive AutomatizarAmbienteFR ; } } package SmartPlaceVLD { enum ComandosArCondicionado { ligar_ar , desligar_ar , aumentar_temperatura , diminuir_temperatura } enum ComandosLuzes { ligar_luz , desligar_luz } value type Void { } value type Real { } value type Boolean { } value type Int { } value type String { } value type SensorTemperatura { unit = SmartPlaceDUD.Celsius dimension = SmartPlaceDUD.Temperatura } datatype DadosCamera { attributes : temPresenca : Boolean ; numPessoas : Int ; } value type SensorPresenca { unit = SmartPlaceDUD.TemPresenca dimension = SmartPlaceDUD.Presenca } } package SmartPlacePTD { import SmartPlaceVLD ; port def ComandosLuzesIPT { flow in ComandosLuzes } port def ComandosLuzesOPT { flow out ComandosLuzes } port def ComandosArCondIPT { flow in ComandosArCondicionado } port def ComandosArCondOPT { flow out ComandosArCondicionado } port def DadosSensorPresencaIPT { flow in SensorPresenca } port def DadosSensorPresencaOPT { flow out SensorPresenca } port def DadosCameraIPT { flow in DadosCamera } port def DadosCameraOPT { flow out DadosCamera } port def DadosSensorTempIPT { flow in SensorTemperatura } port def DadosSensorTempOPT { flow out SensorTemperatura } } package SmartPlaceCND { import SmartPlacePTD ; connector def ComandosLuzesCN { participants : ~ ComandosLuzesIPT : ComandosLuzesIPT ; ~ ComandosLuzesOPT : ComandosLuzesOPT ; flows : ComandosLuzes from ComandosLuzesIPT to ComandosLuzesOPT } connector def ComandosArCondCN { participants : ~ ComandosArCondIPT : ComandosArCondIPT ; ~ ComandosArCondOPT : ComandosArCondOPT ; flows : ComandosArCondicionado from ComandosArCondIPT to ComandosArCondOPT } connector def DadosTempCN { participants : ~ DadosSensorTempIPT : DadosSensorTempIPT ; ~ DadosSensorTempOPT : DadosSensorTempOPT ; flows : SensorTemperatura from DadosSensorTempIPT to DadosSensorTempOPT } connector def DadosSensPresenCN { participants : ~ DadosSensorPresencaIPT : DadosSensorPresencaIPT ; ~ DadosSensorPresencaOPT : DadosSensorPresencaOPT ; flows : SensorPresenca from DadosSensorPresencaIPT to DadosSensorPresencaOPT } connector def DadosCameraCN { participants : ~ DadosCameraIPT : DadosCameraIPT ; ~ DadosCameraOPT : DadosCameraOPT ; flows : DadosCamera from DadosCameraIPT to DadosCameraOPT } } package SmartPlaceCPD { import SmartPlacePTD ; import SmartPlaceVLD ; boundary
	component def SensorPresencaCP { ports : DadosSensorPresOPT : DadosSensorPresencaOPT ; } boundary
	component def SensorTemperaturaCP { ports : DadosSensorTempOPT : DadosSensorTempOPT ; } boundary
	component def CameraCP { ports : DadosCameraOPT : DadosCameraOPT ; } boundary
	component def InterfaceCP { ports : DadosCameraIPT : DadosCameraIPT ; DadoSenPresIPT : DadosSensorPresencaIPT ; DadosSensorTempIPT : DadosSensorTempIPT ; ComandosArCondOPT : ComandosArCondOPT ; } boundary
	component def ArCondicionadoCP { ports : ComandosArCondIPT : ComandosArCondIPT ; } boundary
	component def LuzesCP { ports : ComandosLuzesIPT : ComandosLuzesIPT ; }
	component def ControleLuzes { ports : DadosCameraIPT : DadosCameraIPT ; DadosSensPresIPT : DadosSensorPresencaIPT ; ComandoLuzesOPT : ComandosLuzesOPT ; }
	component def ControleArCondicionado { ports : DadosCameraaIPT : DadosCameraIPT ; DadosSensPreseIPT : DadosSensorPresencaIPT ; ComandoArCondOPT : ComandosArCondOPT ; }
	component def ControleTemperatura { ports : DadosSensTempIPT : DadosSensorTempIPT ; ComandosArCondIPT : ComandosArCondIPT ; ComandosArCondiOPT : ComandosArCondOPT ; }
	component def SmartPlace { ports : Camera : DadosCameraIPT ; SensorPres : DadosSensorPresencaIPT ; Luzes : ComandosLuzesOPT ; ArCond : ComandosArCondOPT ; SensorTemp : DadosSensorTempIPT ; Interface : ComandosArCondIPT ; configuration { components : ControleLuzes : ControleLuzes { using ports : DadosCameraIPT : DadosCameraIPT ; DadosSensPresIPT : DadosSensorPresencaIPT ; ComandoLuzesOPT : ComandosLuzesOPT ; } ControleArCondicionado : ControleArCondicionado { using ports : DadosCameraIPT : DadosCameraIPT ; DadosSensPresIPT : DadosSensorPresencaIPT ; ComandoArCondOPT : ComandosArCondOPT ; } ControleTemperatura : ControleTemperatura { using ports : DadosSensTempIPT : DadosSensorTempIPT ; ComandosArCondIPT : ComandosArCondIPT ; ComandosArCondOPT : ComandosArCondOPT ; } delegations : DadosCameraIPT to Camera DadosSensPresIPT to SensorPres ComandoLuzesOPT to Luzes ComandoArCondOPT to ArCond DadosSensTempIPT to SensorTemp ComandosArCondIPT to Interface } }   activity def ControleTemperaturaAC ( temperatura : SensorTemperatura ) : ( comando : ComandosArCondicionado ) { body { actions : VerificarTemperaturaAN : VerificarTemperaturaAN { using pins : temperatura : SensorTemperatura ; } delegate comando to VerificarTemperaturaAN delegate temperatura to temperatura } } action def VerificarPresencaLuzAN ( presenca : SensorPresenca , presenca : DadosCamera ) : ComandosLuzes { constraint :  pre-condition VerificarPresencaLuzEQ delegate VerificarPresencaLuzAN to comando delegate presenca to presenca 
	delegate  presenca to presenca
	} action def VerificarTemperaturaAN ( temperatura : SensorTemperatura ) : ComandosArCondicionado { constraint : pre-condition VerificarTemperaturaEQ delegate VerificarTemperaturaAN to comando delegate temperatura to presenca } 
	constraint VerificarPresencaLuzEQ ( presenca : DadosCamera , presenca : SensorPresenca ) : (  comando : ComandosLuzes ) {
		equation (presenca = true) ?
		(comando == ComandosLuzes::ligar_luz) :
		(comando == ComandosLuzes::desligar_luz)
	} constraint VerificarTemperaturaEQ ( temperaturaSensor : SensorTemperatura, temperaturaInterface : ComandosArCondicionado ) : ( comando : ComandosArCondicionado ) {
		equation (temperaturaSensor <  temperaturaInterface) ?
		(comando == ComandosArCondicionado::aumentar_temperatura) :
		(comando == ComandosArCondicionado::diminuir_temperatura)
	} activity def ControleLuzAC ( presenca : DadosCamera ) ( presenca : SensorPresenca ) : ( comando : ComandosLuzes ) { body { actions : VerificarPresencaAN : VerificarPresencaLuzAN { using pins : presenca : SensorPresenca ; presenca : DadosCamera ; } delegate comando to VerificarPresencaAN delegate presenca to presenca delegate presenca to presenca } } action def VerificarPresencaArAN ( presencaCam : DadosCamera , presencaSen : SensorPresenca ) : ComandosArCondicionado { constraint : pre-condition VerificarPresencaArEQ delegate VerificarPresencaArAN to comando delegate presencaCam to presenca delegate presencaCam to presenca } activity def ControleArCondicionadoAC ( presenca : DadosCamera ) ( presenca : SensorPresenca ) : ( comando : ComandosArCondicionado ) { body { actions : VerificarPresencaArAN : VerificarPresencaArAN { using pins : presenca : DadosCamera ; presenca : SensorPresenca ; } delegate comando to VerificarPresencaArAN delegate presenca to presenca delegate presenca to presenca } } 
	constraint VerificarPresencaArEQ ( presenca : DadosCamera , presenca : SensorPresenca ) : ( comando : ComandosArCondicionado ) {
		equation (presenca = true) ?
		(comando == ComandosArCondicionado::ligar_ar) :
		(comando == ComandosArCondicionado::desligar_ar)
	} } style IoTStyle { invariant checkSensorCP = "self.checkCPRecursive(self, \'SensorCP\')" invariant checkDataStoreCP = "self.checkCPRecursive(self, \'DataStoreCP\')" invariant checkDeviceCP = "self.checkCPRecursive(self, \'DeviceCP\')" invariant checkSensorOPT = "self.checkPTRecursive(self, \'SensorOPT\')" invariant checkActuatorIPT = "not (self.checkCPRecursive(self, \'ActuatorCP\') xor self.checkPTRecursive(self, \'ActuatorIPT\'))" invariant checkDataIPT = "self.checkPTRecursive(self, \'DataIPT\')" invariant checkDataOPT = "self.checkPTRecursive(self, \'DataOPT\')" invariant checkServiceOPT = "not (self.checkCPRecursive(self, \'GatewayCP\') xor self.checkPTRecursive(self, \'ServiceOPT\'))" invariant checkDeviceIPT = "not (self.checkCPRecursive(self, \'GatewayCP\') xor self.checkPTRecursive(self, \'DeviceIPT\'))" invariant checkSensorDataCN = "self.checkCNRecursive(self, \'SensorDataCN\')" invariant checkDataStoreCN = "self.checkCNRecursive(self, \'DataStoreCN\')" invariant checkActuatorCommandCN = "not (self.checkCPRecursive(self, \'ActuatorCP\') xor self.checkCNRecursive(self, \'ActuatorCommandCN\'))" invariant checkServiceCN = "not (self.checkCPRecursive(self, \'GatewayCP\') xor self.checkCNRecursive(self, \'ServiceCN\'))" invariant checkDeviceDataCN = "not (self.checkPTRecursive(self, \'DeviceOPT\') xor self.checkCNRecursive(self, \'DeviceDataCN\'))" invariant ControllerMustBeEmbeddedInDevice = "self.ControllerCPEmbedded(self)" invariant SensorMustBeConnectedToDeviceOrController = "self.SensorConnection(self)" invariant ActuatorMustBeConnectedToDeviceOrController = "self.ActuatorConnection(self)" invariant SensorAndActuatorDontCommunicate = "self.Communication(self)" invariant SensorDataCNMustNotBeMultiplex = "self.checkBindingsRecursive(self, \'SensorDataCN\')" invariant ActuatorCommandCNMustNotBeMultiplex = "self.checkBindingsRecursive(self, \'ActuatorCommandCN\')" invariant DeviceDataCNMustNotBeMultiplex = "self.checkBindingsRecursive(self, \'DeviceDataCN\')" abstract component def SensorCP [ 1 , -1 ] { ports : SensorOPT : out any [ 1 , -1 ] } abstract component def ActuatorCP [ 0 , -1 ] { ports : ActuatorIPT : in any [ 1 , -1 ] } abstract component def DeviceCP [ 1 , -1 ] { ports : DeviceOPT : out any [ 0 , -1 ] SensorIPT : in any [ 0 , -1 ] ActuatorOPT : out any [ 0 , -1 ] ServiceIPT : in any [ 0 , -1 ] compose { SensorCP , ActuatorCP , ControllerCP , GatewayCP , DataStoreCP } } abstract component def DataStoreCP [ 1 , -1 ] { ports : DataOPT : out any [ 1 , -1 ] DataIPT : in any [ 1 , -1 ] } abstract component def ControllerCP [ 0 , -1 ] { ports : SensorIPT : in any [ 0 , -1 ] ActuatorOPT : out any [ 0 , -1 ] } abstract component def GatewayCP [ 0 , -1 ] { ports : DeviceIPT : in any [ 1 , -1 ] ServiceOPT : out any [ 1 , -1 ] ServiceIPT : in any [ 0 , -1 ] compose { DataStoreCP } } abstract component def IoTARCH { compose { SensorCP , ActuatorCP , DeviceCP , GatewayCP , DataStoreCP } } abstract connector def SensorDataCN { participants : ~ SensorOPT : out any ~ SensorIPT : in any flows : flow SensorOPT to SensorIPT } abstract connector def ActuatorCommandCN { participants : ~ ActuatorOPT : out any ~ ActuatorIPT : in any flows : flow ActuatorOPT to ActuatorIPT } abstract connector def DeviceDataCN { participants : ~ DeviceOPT : out any ~ DeviceIPT : in any flows : flow DeviceOPT to DeviceIPT } abstract connector def DataStoreCN { participants : ~ DataOPT : out any ~ DataIPT : in any flows : flow DataOPT to DataIPT } abstract connector def ServiceCN { participants : ~ ServiceOPT : out any ~ ServiceIPT : in any flows : flow ServiceOPT to ServiceIPT } abstract activity def Monitoring abstract activity def Analysis abstract activity def Planning abstract activity def Execution }